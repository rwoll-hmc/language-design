_Fill in each this file with your responses, placing each response after its
corresponding question._

---

**Question**

Pick three quotes from the readings about language design. Good candidates 
are:

   + Something you agreed with / resonates with your own experience
   + Something you disagree with
   + Something that is interesting, a new idea or perspective you'd like to remember
   + Something you didn't understand

For each quote, describe what it was about the quote that led you pick it.

**Response**

1. Cathedral/Bazaar Quote
2. Wizard Quote

   > "The problem is that programming languages are created either by committee
   > or by extreme technical wizards with magical math powers."
   
3. Documentation Quotes from "How to Design a Good API..."


---

**Question**

How would you know a well-designed language? What are the symptoms? How would
you know a poorly designed language? What are the symptoms?

**Response**

+ Self-Documenting: cite API design article
   + Cite "Why Aren't Computer Languages Designed Better" (see: section with example
     loop code)
+ Extension should look like it fits; follow a pattern; cite first paper
+ Consistency
+ Efficiency with features: don't overload a language for its use-case
+ cite `gray` example
+ Bad: hard to read
+ Bad: unnatural or unobvious error messages

---

**Question**

How do the themes of _Growing a Language_ relate to the "sound lab" we did this week?

**Response**

+ Fluency
+ Creating a pattern: chaining and natural use
+ Mode of discussion

---
 
**Question**


In what way is an API a language? 

**Response**

+ Fluency in expressions
+ Sytematic/Patterns
+ Design of both is an art&mdash;not a science
+ Allows you to interact with another entity
+ Both necessitate good naming choices

---

**Question**

What does the post on grayscale tell us about the process of API design?

**Response**

+ It should be interactive: have users vote (maybe)
+ Names make a huge difference in usability
+ Need to weigh pros and cons&mdash;especially compatibility issues
+ There are many ways to do the same thing

---

**Question**

The Yang and Rabkin article talks mainly about general-purpose languages. In 
what ways do the themes apply to the study and creation of DSLs?

**Response**

---

**Question**

The Pavlus article mentions the researchers' comments that people preferred
"natural-language replacements for some of the more abstruse syntax". In other 
words, people found it easier to work with code that looks more like a human language (e.g.,
English). Consider the following quote by William R. Cook, one of the creators
of AppleScript:


> The experiment in designing a language that resembled natural languages (English
> and Japanese) was not successful. It was assumed that scripts should be
> presented in “natural language” so that average people could read and write
> them. … In the end the syntactic variations and flexibility did more to confuse
> programmers than to help them out. It is not clear whether it is easier for
> novice users to work with a scripting language that resembles natural language,
> with all its special cases and idiosyncrasies. The main problem is that
> AppleScript only appears to be a natural language: in fact, it is an artificial
> language, like any other programming language. … even small changes to the
> script may introduce subtle syntactic errors that baffle users. It is easy to
> read AppleScript, but quite hard to write it.
[[Cook 2007, page 1-20]](https://dl.acm.org/citation.cfm?doid=1238844.1238845)

Are these two experiences of natural languages at odds with one another? Would
you choose to include natural language in the design of a DSL? If so, how might
you do so? If not, why not?

**Response**

+ There needs to be a good balance
   + It's important to have fluency and naturalness, but also have a very strict
     less optionful language. It doesn't need to read like Shakespeare, but it
     shouldn't read like Perl.
+ Needs to be clear to a user that grammar may be broken
+ Maybe bring up should.js
+ Higher learning curve with non-natural language, but once you learn to think
  in a certain language, it seems more useful.
  + Perhaps bring up last weeks reading (Fowler): it shoud still feel like a
    programming language
+ Frustrating learning new syntax&mdash;especially syntactic "sugar"
+ Functionally meaningless words, although useful in creating a more
  natural read, are not necissarily helpful to programmers writing
   + Find balance between adding keywords to just make sense verse over-clutter
     and vague choices

---

**Question**

Briefly describe how you split up the work for this assignment.

**Response**


---
